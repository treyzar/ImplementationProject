У меня уже есть существующий проект:
- Backend: Django 4.x + Django REST Framework на Python 3.10.
- Frontend: React 18 + TypeScript, React Router, сборка через современный бандлер (например, Vite или CRA).
Ничего не ломай и не переписывай кардинально — нужно ДОБАВИТЬ новый модуль.

Твоя задача:
СОЗДАТЬ с нуля функционал "Конструктор документов" (Document Builder):
1) backend-приложение в Django (views, serializers, модели, парсеры DOCX/PDF, urls, настройки);
2) frontend-страницу конструктора документов на React;
3) ПОДРОБНУЮ текстовую инструкцию по интеграции всего этого в мой существующий проект (и backend, и frontend).

Везде:
- НЕЛЬЗЯ использовать заглушки, псевдокод, "TODO", "pass", "..." и т.п.
- Нужен ПОЛНОЦЕННЫЙ рабочий код со всеми импортами.
- Код должен быть совместим с Python 3.10.

==================================================
1. BACKEND: Django-приложение "documents"
==================================================

Создай новое Django-приложение "documents" (если его ещё нет) со следующими файлами:

- documents/__init__.py
- documents/apps.py
- documents/models.py
- documents/serializers.py
- documents/views.py
- documents/urls.py
- documents/utils.py   (для функций парсинга DOCX и PDF)
- при необходимости: documents/permissions.py, documents/services.py и т.п.

ВАЖНО: НЕ привязывайся к примерам моделей. Сам СПРОЕКТИРУЙ модели и структуру данных, исходя из ТЗ ниже. Модели должны быть достаточно гибкими, чтобы:

- хранить шаблоны документов, созданные пользователем конструктором (текстовые блоки, таблицы, картинки и т.д.);
- хранить загруженные файлы-источники (DOCX и PDF), с результатом их парсинга (текст по страницам и, по возможности, элементарная структура).

1.1. Общие требования к моделям

Самостоятельно продумай и реализуй модели, которые покрывают:

- Пользовательские шаблоны документов (Document Templates):
  - Привязка к пользователю (owner / author).
  - Название, краткое описание.
  - JSON-поле или другая подходящая структура для хранения схемы документа (блоки, позиции, стили, zoom и т.п.).
  - Даты создания и обновления.
- Загруженные исходные файлы (Source Files):
  - Привязка к пользователю и, опционально, к конкретному шаблону.
  - Поле FileField для хранения исходного файла.
  - Оригинальное имя файла, MIME-тип, размер.
  - Расширение обязательно должно проверяться (минимум pdf, docx).
  - JSON-поле для результата парсинга (например, список страниц с текстом).
  - Дата загрузки.
- При необходимости:
  - Любые дополнительные модели (например, сохранённые версии документа, предпросмотр и т.п.) — на твоё усмотрение, но без фанатизма. Главное — полезно и практично.

Используй стандартные возможности Django 4.x и типы полей, совместимые с Python 3.10. Если используешь JSONField — явно укажи, какой именно (из Django или Postgres), и корректно импортируй.

1.2. Парсинг DOCX и PDF (documents/utils.py)

Реализуй в `documents/utils.py` РЕАЛЬНЫЕ функции:

- `parse_docx_to_pages(file_obj) -> list[dict]`
- `parse_pdf_to_pages(file_obj) -> list[dict]`

Требования:

- Используй реальные библиотеки:
  - для DOCX: `python-docx` (библиотека `docx`);
  - для PDF: `pdfplumber` или `PyPDF2`.
- Каждая функция должна возвращать список словарей вида:
  - `[{"page": 1, "text": "<текст страницы 1>"}, {"page": 2, "text": "<текст страницы 2>"}, ...]`.
- Сделай простую, но рабочую обработку ошибок:
  - если файл повреждён — аккуратно подними осмысленное исключение или верни пустой список с логированием.
- Не оставляй заглушки — весь код должен быть рабочим.

1.3. Сериализаторы (documents/serializers.py)

Реализуй сериализаторы для:

- Модели шаблона документа (Document Template) — полный CRUD.
- Модели загруженного файла (Source File) — в том числе parsed_content.
- Отдельный сериализатор для загрузки файла:
  - принимает файл и, опционально, id привязанного шаблона;
  - валидирует тип (pdf/docx), размер и т.п. (разумная валидация, без жёсткого хардкода).

Список полей сериализаторов определи САМ, исходя из моделей, но так, чтобы:

- На фронт возвращались:
  - id
  - основные метаданные (название, описание, даты)
  - JSON-схема шаблона
  - для файлов — имя, MIME-type, parsed_content (для просмотра на фронте)
- Для операций создания/обновления можно использовать те же сериализаторы (или отдельные — на твой выбор).

1.4. Views (documents/views.py)

Используй Django REST Framework (APIView, GenericAPIView, ViewSet, ModelViewSet — по своему выбору, главное, чтобы было удобно и логично).

Нужно реализовать:

- ViewSet / набор generic views для управления шаблонами документов:
  - список шаблонов текущего пользователя;
  - просмотр отдельного шаблона;
  - создание нового шаблона;
  - обновление существующего (PATCH/PUT);
  - удаление.
  - Обязательно фильтруй по `request.user` (доступ только к своим шаблонам).

- ViewSet / набор generic views для загруженных файлов:
  - список файлов текущего пользователя;
  - просмотр данных отдельного файла;
  - удаление файла (при необходимости).

- Отдельный endpoint для загрузки и автопарсинга файла:
  - POST-метод, принимает:
    - файл (DOCX или PDF);
    - опционально id шаблона документа для привязки.
  - Определяет MIME-тип и расширение.
  - Валидирует допустимость формата.
  - Сохраняет файл в модель загруженных файлов.
  - Вызывает парсер (DOCX или PDF).
  - Сохраняет результат в JSON-поле.
  - Возвращает сериализованные данные загруженного файла.

Во всех view НЕ используй заглушки. Выполни:

- Полный импорт всех зависимостей.
- Настройку permission-классов (например, IsAuthenticated).
- Корректную работу `get_queryset()` с фильтром по пользователю.

1.5. URL-маршруты (documents/urls.py и корневой urls.py)

Реализуй:

- `documents/urls.py` с DRF Router (DefaultRouter или SimpleRouter) для:
  - шаблонов документов;
  - загруженных файлов.
- Отдельный path для upload-view (например, `upload-source-file/`).

Примерный вид конечных API-эндпоинтов (ты можешь немного менять имена, но они должны быть понятными):

- `api/documents/templates/`
- `api/documents/templates/<id>/`
- `api/documents/source-files/`
- `api/documents/source-files/<id>/`
- `api/documents/upload-source-file/` (POST)

В корневом `urls.py` покажи КОНКРЕТНО, что нужно добавить, чтобы маршруты `documents` стали доступны.

1.6. Настройки backend

В ответе ты обязан явно указать:

- Какую зависимость нужно добавить в requirements для:
  - `python-docx`;
  - библиотеки для PDF (`pdfplumber` или `PyPDF2`).
- Как добавить `"documents"` в `INSTALLED_APPS`.
- Какие миграции нужно выполнить.
- Любые дополнительные настройки (например, MEDIA_ROOT/MEDIA_URL, если они нужны для загрузки файлов).

==================================================
2. FRONTEND: Страница "Document Builder"
==================================================

Создай страницу визуального конструктора документов с интуитивным интерфейсом. Фронтенд на React + TypeScript.

2.1. Общая структура

Добавь новые файлы (пути можно адаптировать под стандартный `src`):

- `src/pages/DocumentBuilderPage.tsx` — основная страница.
- `src/components/document-builder/DocumentCanvas.tsx`
- `src/components/document-builder/SidebarBlocks.tsx`
- `src/components/document-builder/SidebarFiles.tsx`
- `src/components/document-builder/InspectorPanel.tsx`
- `src/components/document-builder/Toolbar.tsx`
- `src/components/document-builder/types.ts`
- `src/api/documentBuilderApi.ts`

Если структура проекта чуть другая — всё равно покажи ПОЛНЫЙ содержимый код этих файлов, чтобы их можно было просто добавить в `src`.

2.2. Типы данных (src/components/document-builder/types.ts)

Самостоятельно определи интерфейсы типов, примерно следующего смысла:

- Типы блоков документа (text, table, image, signature, rectangle и т.п.);
- Структура блока (id, тип, координаты, размеры, поворот, content, style и т.д.);
- Структура данных шаблона (список блоков, zoom, возможно дополнительные поля);
- DTO-шаблона, приходящего с backend (id, title, description, data, created_at, updated_at);
- Тип для загруженных файлов (id, original_name, mime_type, parsed_content и др.).

Важно:
- Типы должны реально использоваться в компонентах страницы.
- Не оставляй ничего "как-нибудь" — определи чёткие интерфейсы.

2.3. API-клиент (src/api/documentBuilderApi.ts)

Реализуй модуль с функциями, работающими с backend:

Минимальный набор:

- `getTemplates()` — получение списка шаблонов.
- `getTemplate(id: number)`.
- `createTemplate(payload)` — создание.
- `updateTemplate(id: number, payload)` — обновление.
- `deleteTemplate(id: number)` — удаление (если нужно).
- `getSourceFiles()` — список загруженных файлов.
- `uploadSourceFile(file: File, templateId?: number)` — загрузка файла через FormData.

Требования:

- Используй либо `fetch`, либо `axios`. Если используешь `axios`, создай или используй типичный instance.
- Все пути должны соответствовать маршрутам, которые ты описал в backend.
- Обрабатывай базовые ошибки (try/catch или `.catch`) с хотя бы минимальной логикой.

2.4. Страница DocumentBuilderPage.tsx

Реализуй полноценную страницу:

- Верхняя панель (Toolbar):
  - Поле ввода названия шаблона.
  - Кнопки:
    - "Сохранить шаблон" (создать или обновить через API);
    - "Загрузить шаблон" (селект/дропдаун по списку шаблонов);
    - "Загрузить файл (DOCX/PDF)" (input type="file" + вызов uploadSourceFile);
    - "Предпросмотр" (можно простая модалка, либо отдельный режим отображения);
    - "Отменить" / "Повторить" (undo/redo в локальном состоянии);
    - Управление масштабом (Zoom - / Zoom +, например 50–200%).

- Левая панель:
  - Список типов блоков (Text, Table, Image, Signature, Rectangle и т.д.).
  - По клику создаётся новый блок на холсте.

- Центральная область:
  - `DocumentCanvas` — визуализация листа документа (например, формат A4 по условным единицам).
  - Возможность:
    - выделять блоки;
    - перетаскивать их мышью (drag&drop);
    - отображать стиль (рамка, шрифт, текст) с учётом zoom.

- Правая панель:
  - `InspectorPanel` для редактирования свойств выбранного блока:
    - координаты (x, y);
    - ширина/высота;
    - текст (для текстовых блоков);
    - шрифт, размер, жирность, выравнивание;
    - свойства рамки и др.

- Дополнительно:
  - `SidebarFiles` с отображением списка загруженных файлов (из API).
  - Возможность открыть parsed_content (например, в модальном окне или панели) и посмотреть текст по страницам.

Реализуй:

- Хранилище состояния (можно через React useState/useReducer):
  - список блоков;
  - zoom;
  - выбранный блок;
  - стек undo/redo.
- Логику:
  - добавления/удаления блоков;
  - перемещения блоков;
  - изменение свойств блока;
  - undo/redo.

Никаких заглушек — компоненты должны работать и быть связаны между собой.

2.5. Роутинг

Предположим, что используется React Router v6.

- Добавь маршрут:
  - `"/documents/builder"` → компонент `DocumentBuilderPage`.
- Покажи КОНКРЕТНЫЕ изменения в существующем файле с маршрутами (например, `src/App.tsx` или `src/router.tsx`):
  - импорт компонента;
  - добавление `<Route path="/documents/builder" element={<DocumentBuilderPage />} />`.

==================================================
3. ОБЩИЕ ТРЕБОВАНИЯ К КОДУ
==================================================

1. НИКАКИХ заглушек:
   - Не использовать `pass`, `...`, `# TODO`, фразы "здесь будет логика" и т.п.
   - Все методы и функции должны содержать рабочий код.

2. ПОЛНЫЙ КОД ФАЙЛОВ:
   - Для backend-файлов (`models.py`, `serializers.py`, `views.py`, `utils.py`, `urls.py`, изменения в settings.py и корневом urls.py) — показать ПОЛНОЕ содержимое.
   - Для frontend-файлов (`types.ts`, `documentBuilderApi.ts`, компоненты, страница, роутинг) — тоже ПОЛНОЕ содержимое.
   - Везде указать ВСЕ импорты.

3. Совместимость:
   - Backend код должен быть совместим с Python 3.10 и Django 4.x.
   - Не использовать возможности, недоступные в Python 3.10.

==================================================
4. ПОДРОБНАЯ ИНСТРУКЦИЯ ПО ВНЕДРЕНИЮ
==================================================

В конце ответа ОБЯЗАТЕЛЬНО добавь большой, подробный раздел "Инструкция по интеграции", в котором Пошагово опишешь:

1) Для backend:
   - какие новые зависимости нужно установить (точные команды pip install);
   - что добавить в `INSTALLED_APPS`;
   - какие настройки MEDIA/STATIC нужно проверить/добавить;
   - как подключить urls приложения "documents" в корневой `urls.py`;
   - какие команды миграций нужно выполнить (конкретные примеры);
   - как проверить работу API (примеры запросов через curl или Postman).

2) Для frontend:
   - какие новые файлы нужно создать и куда их положить;
   - если используется axios — как интегрировать `documentBuilderApi.ts` с существующим axios-instance (если такой предполагается);
   - какие изменения внести в существующий роутер (с конкретным фрагментом кода);
   - как открыть страницу в браузере (какой URL);
   - как настроить базовый URL для запросов к backend (если это требуется).

3) Общие рекомендации:
   - как безопасно внедрить изменения в уже работающий проект (например, сначала создать новую ветку);
   - на что обратить внимание при деплое (миграции, статика, медиа-файлы).

Не пропускай этот раздел — он обязателен.
